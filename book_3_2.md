# 3.2 Arbitrary Configuration Because of Crashes

The above technique can be extended to prove that a configuration can be reached in which the states of the processors are any possible state in the execution $E$ described in the previous section, and the messages in the links are any possible sequence of messages sent during $E$. Before we describe the details, let us note that it is possible that corrupted frames will not be identified as being corrupted and will be accepted by the sender and the receiver, causing an undesired state change and frame transmission.

The error-detection codes augmenting the frames ensure that the probability of such a scenario is small. Nevertheless, even if we assume that no undetected frame corruption is possible, it is still possible that a combination of crashes and frame losses will bring the system to an arbitrary configuration.

Let $\mathcal{S}(\mathcal{R})$ be the set of states of the sender (receiver, respectively) during a reference execution $E$ (as defined in the previous section). Let $\mathcal{F_S}(\mathcal{F_R})$ be the set of frames sent by the sender (receiver, respectively) during $E$. Let $\mathcal{C}$ be a set of all configurations for which the state of the receiver is a state in $\mathcal{R}$, the state of the sender is a state in $\mathcal{S}$, and the contents of $q_{r,s}$ and $q_{s,r}$ are any finite possible sequence of frames in $\mathcal{F_R}$ and $\mathcal{F_S}$, respectively.

We will now show that any configuration in $\mathcal{C}$ can be reached from the first configuration of $E$ by a sequence of crashes of the sender and the receiver and frame losses. Intuitively, we use the pumping technique to accumulate a longer sequence of frames than was used in proving the impossibility of a crash-resilient data-link algorithm.

Once we have the entire sequence of frames sent from the receiver to the sender during $E$ in $q_{r,s}$, we can start a new replay of $E$ while keeping the frames sent during $E$ in the system. Let us start with the configuration reached by using the pumping technique to accumulate in $q_{r,s}$ all frames sent from the receiver to the sender during $E$.

We continue from the configuration reached by the pumping technique in which the sequence of frames sent from the receiver to the sender during $E$ are accumulated in $q_{r,s}$. Our first goal is to have two such sequences in a row stored in $q_{r,s}$. To achieve this, we crash the sender, let the sender send the first frame $f_{s1}$ to the receiver, then crash the sender again and let the sender replay $E$, while accepting the frames stored in $q_{r,s}$. The sequence of frames stored in $q_{s,r}$ will be $f_{s1}$ and then $f_{s1}$ and the rest of the frames the sender sends during $E$. Now we use the above sequence as an input for the receiver: we crash the receiver, let the receiver accept $f_{s1}$ and send $f_{r1}$, crash the receiver again, and let it replay $E$, accepting the frames stored in $q_{s,r}$ while producing $f_{r1}$, $f_{r2}$, · · ·, $f_{rk}$.

Our attention returns to the sender: the sender crashes, then sends $f_{s1}$, receives $f_{r1}$, and sends $f_{s2}$. Then we crash the sender again and let it replay $E$ using the rest of the sequence of frames stored in $q_{r,s}$. We obtain a configuration in which the sequence of frames in $q_{s,r}$ is $f_{s1}$, $f_{s2}$, $f_{s1}$, $f_{s2}$, $f_{s3}$, · · · $f_{sk}$. We continue in the same fashion, reaching a configuration in which $f_{s1}$, $f_{s2}$, $f_{s3}$, · · ·, $f_{sk}$, $f_{s1}$, $f_{s2}$, $f_{s3}$, · · ·, $f_{sk}$ appear in $q_{s,r}$. Let us denote $f_{s1}$, $f_{s2}$, $f_{s3}$, · · ·, $f_{sk}$ by $\mathcal{F}_{sE}$ and $f_{r1}$, $f_{r2}$, $f_{r3}$, · · ·, $f_{rk}$ by $\mathcal{F}_{rE}$. Once we reach a configuration in which $\mathcal{F}_{sE}$ appears twice in a row in $q_{s,r}$, we start accumulating one additional sequence to reach a configuration in which $\mathcal{F}_{sE}$ appears three times in a row in $q_{s,r}$. To do so, we will need to crash the sender (and the receiver) three times: once at the beginning of the replay and once before receiving either of the two $\mathcal{F}_{rE}$ ($\mathcal{F}_{sE}$, respectively), which are already stored in the system.

Let us use the notation $\mathcal{F}^2_{sE}$ to denote the sequence $f_{s1}$, $f_{s2}$, · · ·, $f_{sk}$, $f_{s1}$, $f_{s2}$, · · ·, $f_{sk}$; in general, the notation $\mathcal{F}^i_{sE}$ denotes a sequence in which $\mathcal{F}_{sE}$ appears $i$ times in a row. For any finite $i$, this technique can be extended to reach a configuration in which $\mathcal{F}^i_{sE}$ appears in $q_{s,r}$.

Let $k_1$ ($k_2$) be the number of frames in $q_{s,r}$ ($q_{r,s}$, respectively) in the arbitrary configuration $c_a$ that we choose from $\mathcal{C}$, and let $i$ be $k_1 + k_2 + 2$. We use the above pumping technique to accumulate $\mathcal{F}^i_{sE}$ in $q_{s,r}$. Then we let the receiver replay $E$ $k_2+1$ times using the frames stored in $q_{s,r}$, reaching a configuration in which $q_{s,r}$ contains $\mathcal{F}^{k_1+1}_{sE}$ and $q_{r,s}$ contains $\mathcal{F}^{k_2+1}_{rE}$.

Now we replay $E$ until the desired states of the sender and the receiver are reached. To do this, we let the sender replay using the first copy of $\mathcal{F}_{rE}$ stored in $q_{r,s}$ until the sender reaches the desired state. We lose all frames produced by the sender at this stage and also the leftovers of the copy of $\mathcal{F}_{rE}$ that we used. The same is done for the receiver using the first copy of $\mathcal{F}_{sE}$. At this stage we have the sender and the receiver in the states they have in $c_a$, and we have to make sure only that the sequences of frames stored in the communication links are identical to the sequence in $c_a$. Let us consider the frames stored in $q_{s,r}$, since the case of $q_{r,s}$ is analogous. We have $k_1$ copies of $\mathcal{F}_{sE}$. We can use the first copy to ensure that the first frame $f_{s1a}$ that appears in $q_{s,r}$ of ca will exist — losing all frames from this copy of $\mathcal{F}_{sE}$ except $f_{s1a}$. The same can be done for the second frame $f_{s2a}$ that appears in $q_{s,r}$ of $c_a$, using the the second copy of $\mathcal{F}_{sE}$, and so on.

Figure 3.2 depicts how an additional copy of $\mathcal{F}_{sE}$ is accumulated in $q_{s,r}$. Eight configurations numbered 1 to 8 to are presented. In configuration 1, a single copy of $\mathcal{F}_{rE}$ is in transit from the receiver to the sender. Configuration 2 is derived from configuration 1 by steps of $S$ in which $S$ crashes and then spontaneously sends $f_{s1}$. Configuration 3 is derived from the second configuration by steps of $S$ in which $S$ crashes and spontaneously sends (an additional) $f_{s1}$, then $S$ receives $f_{r1}$, $f_{r2}$ and $f_{r3}$ and sends $f_{s2}$, and $f_{s3}$ in response (the sender sends a frame upon receiving $f_{r3}$). Configuration 4 is obtained from the third configuration by a crash of the receiver and then a receive of the first copy of $f_{s1}$ in $q_{s,r}$ and a following send of $f_{r1}$. Configuration 5 is reached from the fourth configuration by a crash of the receiver, then the acceptance of $f_{s1}$, $f_{s2}$, and $f_{s3}$ and send operations of $f_{r1}$, $f_{r2}$, and $f_{r3}$ in response.

Crashes are not considered a severe type of fault (e.g., Byzantine faults are more severe, as explained in chapter 6). In this chapter we have proved that it is impossible to achieve a basic task when crashes cause the processors to change state to an after-crash state. One approach to proving correctness of a distributed algorithm is to show that consistency can be preserved by starting in a consistent configuration (a safe configuration) and proving that any step preserves the consistency. The above technique shows that this approach is doomed to failure when crashes are possible, since consistency may not be preserved in the presence of crashes.

![figure_3.2](images/figure_3.2.png)

Finally, we remark that a crash-resilient data-link algorithm exists when a bound on the number of frames in transit is known. A crash-resilient data-link algorithm also exists when a bound on the transmission time is known. Let us describe a crash resilient data-link algorithm that uses a bound on the number of frames in transit. The algorithm uses an initialization procedure following the crash of the sender or the receiver. This initialization procedure ensures that the alternating-bit protocol presented in figure 2.14 is properly initialized, and that any message that is fetched by the sender following the last crash is delivered.

Let $bound$ be the maximal number of frames that can be in transit in the links that connect both the sender to the receiver and the receiver to the sender. Whenever the sender recovers from a crash (starts in an after-crash state) it invokes a clean procedure. The sender repeatedly sends a frame $<clean, 1>$ until receiving $<ackClean, 1>$; then the sender repeatedly sends $<clean, 2>$ until receiving $<ackClean, 2>$. This procedure continues until the sender sends $<clean, bound + 1>$ and receives $<ackClean, bound + 1>$.

Once more the missing-label concept presented in section 2.6 is used. In any initial configuration at least one label $x$ in the range 1 to $bound+1$ does not exist. Thus, when the sender receives the first acknowledgment $<ackClean, x>$  there is no other label in transit. Moreover, when the sender receives the first acknowledgment $<ackClean, y>$, for any $y \geq x$, the only label in transit is $y$. The sender does not know the value $x$ of the missing label, but nevertheless when the sender receives the first acknowledgment $<ackClean, bound + 1>$  it can be sure that the only label in transit is $bound+1$. It can therefore initialize the alternating algorithm, in particular assign 0 to ${bit}_s$ and fetch a new message to send to the receiver. Similarly, whenever the receiver receives a frame $<ackClean, bound + 1>$ it initializes its alternating-bit algorithm, assigning 1 to ${bit}_r$. The above initialization procedure ensures that whenever the sender fetches a new message to be sent, all the frames in transit have the same label value.

The actions of the receiver starting from an after-crash state are yet to be defined. As a first try, let us assume that when the first frame $<FrameBit, msg>$ arrives at the receiver following a crash, the receiver assigns ${bit}_r := FrameBit$ and delivers the message $msg$ to the output queue. In such a case it is possible that the receiver delivers an extra copy of $msg$ — one before the crash and one after the crash. This is possible because the sender repeatedly sends the same frame until an acknowledgment arrives, possibly causing the accumulation of several copies of the same frame in the link that transfers messages from the sender to the receiver. Can such duplicate delivery be avoided? In other words, can we guarantee at most one delivery (i.e., no duplication but possibly omission) of messages, and still ensure that every message fetched by the sender following the last crash (of either the sender or the receiver) is delivered—i.e., can we guarantee exactly-once delivery following the last crash? A first try at satisfying this requirement is to change the actions of the receiver following a crash to exclude the output of the message that arrives in the first frame, but still to assign to ${bit}_r$ the $FrameBit$ of the first arriving frame. In this case it is possible that, following the crash of $R$, $S$ fetches a message that is not accepted by $R$ — violating the requirement of exactly once delivery following the last crash. ${bit}_r$ should be somehow initialized to make sure that a message fetched following the crash will be delivered. One solution that satisfies the requirements is to program the sender to send each message in frames with labels 0 until an acknowledgment is received and then to send the same message in frames with label 1 until an acknowledgment is received. The receiver will deliver a message only when the message arrives in a frame with label 1 immediately after it arrived in a frame with label 0. Thus, if the sender fetches a message msg following the crash of $R$, a frame with $<0, msg>$ must arrive at the receiver before the sender starts sending $<1, msg>$, ensuring that bi tr is set to 0 and then to 1.
