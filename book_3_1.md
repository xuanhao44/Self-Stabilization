# 3.1 Initialization of a Data-Link Algorithm in the Presence of Faults

The data-link layer is responsible for delivering messages from a *sender* to a *receiver* that are directly connected. Recall that the communication channel connecting the sender and the receiver is not reliable; information sent from the sender to the receiver (and in the opposite direction) can be corrupted or even lost. In order to deliver a message, the sender sends sequences of bits (usually at a constant rate) to the receiver. Each sequence is called a frame. The sender stops sending bits for (at least) a short period between two consecutive frame transmissions.

数据链路层负责将消息从 *发送方* 传递到直接连接的 *接收方*。请记住，连接发送方和接收方的通信信道是不可靠的；从发送方发送到接收方的信息（以及相反方向的信息）可能会被损坏甚至丢失。为了传递消息，发送方将比特序列（通常以恒定速率）发送给接收方。每个序列称为一个帧。发送方在两个连续的帧传输之间会停止发送比特（至少）一小段时间。

Error-detection codes are used to identify and discard corrupted frames. Frame retransmission is used to cope with the possibility of frame corruption or loss. One retransmission strategy is the alternating-bit algorithm presented in figure 2.14, which can be used to implement a reliable data-link layer. Every message received by the sender from the network layer is repeatedly sent in a frame to the receiver until the receiver acknowledges receipt. The sender is then ready to receive and handle a new message of the network layer.

错误检测码用于识别和丢弃损坏的帧。帧重传用于应对帧损坏或丢失的可能性。图 2.14 中介绍的一种重传策略是交替位算法，它可用于实现可靠的数据链路层。发送方从网络层接收到的每条消息都会在一个帧中反复发送给接收方，直到接收方确认收到。然后，发送方准备接收和处理网络层的新消息。

In more detail: when the system is initialized, there are no frames in transit. Thus, the sender uses the sequence number ${bit}_s = 1$, while the receiver uses the sequence number ${bit}_r = 0$. The sender repeatedly sends the frame $<m_1, 1>$ with the first message received from the network layer $m_1$ and a bit value 1, which is the value of bits. The receiver accepts every message from a frame with a bit value different from ${bit}_r$. In particular, the receiver accepts $m_1$ and delivers it to the network layer. At the same time, the receiver changes ${bit}_r$ to the value of the bit in the frame of the accepted message; i.e., ${bit}_r$ is assigned the value 1 when $m_1$ is delivered. In addition, every frame $<m, bit>$ that arrives at the receiver is acknowledged by the receiver by the transmission of a frame $<bit>$. Therefore, eventually the sender receives a frame $<1>$ from the receiver that indicates the acceptance of $m_1$ by the receiver.

更详细地说：当系统初始化时，没有帧在传输中。因此，发送方使用序列号 ${bit}_s = 1$，而接收方使用序列号 ${bit}_r = 0$。发送方反复发送带有从网络层接收到的第一条消息 $m_1$ 和比特值 1 的帧 $<m_1, 1>$。接收方接受每个比特值不同于 ${bit}_r$ 的帧中的消息。特别地，接收方接受 $m_1$ 并将其传递到网络层。同时，接收方将 ${bit}_r$ 更改为已接受消息帧中的比特值；即，当 $m_1$ 被传递时，${bit}_r$ 被赋值为 1。此外，每个到达接收方的帧 $<m, bit>$ 都会被接收方通过发送一个 $<bit>$ 帧来确认。因此，最终发送方会收到一个来自接收方的帧 $<1>$，表示接收方已接受 $m_1$。

The sender changes the value of ${bit}_s$ to 0 and is ready to send message $m_2$ by repeatedly transmitting the frame $<m_2, 0>$. Note that when the sender sends the frame $<m_2, 0>$, no frame with sequence number 0 is in the system. Therefore, the sender will receive an acknowledgment $<0>$ only after ${bit}_r$ is changed to 0; in other words, only after $m_2$ is delivered by the receiver to the network layer. Once the sender receives an acknowledgment $<0>$, no frame with sequence number 1 exists in the system.

发送方将 ${bit}_s$ 的值改为 0，并准备通过反复传输帧 $<m_2, 0>$ 来发送消息 $m_2$。请注意，当发送方发送帧 $<m_2, 0>$ 时，系统中没有序列号为 0 的帧。因此，发送方只有在 ${bit}_r$ 被改为 0 后才会收到确认 $<0>$；换句话说，只有在接收方将 $m_2$ 传递到网络层后，发送方才会收到确认 $<0>$。一旦发送方收到确认 $<0>$，系统中就不存在序列号为 1 的帧。

Is there a data-link algorithm, such as the alternating-bit algorithm, that can tolerate crashes of the sender and the receiver? To answer this question, we must decide how a crash affects the system. It is usually assumed that a crash causes the sender and receiver to reach an initial state. Therefore, it is obvious that a sender crash occurring immediately after the sender fetches a message m from the network layer, and before any frame is actually sent to the receiver, may result in a message loss, since no information concerning m is available. With this in mind, we want to check whether it can be guaranteed that every message fetched by the sender following the last crash of either the sender or the receiver will arrive at its destination. One way to ensure this is by invoking an initialization procedure; for example, for the alternating-bit algorithm, the initialization procedure initializes ${bit}_s$ to hold 1 and ${bit}_r$ to hold 0, and ensures that no frame with label 0 or 1 is in transit. Then the initialization procedure signals the sender to start fetching messages.

是否存在一种数据链路算法，例如交替位算法，可以容忍发送方和接收方的崩溃？要回答这个问题，我们必须决定崩溃如何影响系统。通常假设崩溃会导致发送方和接收方达到初始状态。因此，很明显，如果发送方在从网络层获取消息 m 后立即发生崩溃，并且在任何帧实际发送到接收方之前，可能会导致消息丢失，因为没有关于 m 的信息。在这种情况下，我们希望检查是否可以保证发送方在发送方或接收方最后一次崩溃后获取的每条消息都能到达目的地。确保这一点的一种方法是调用初始化程序；例如，对于交替位算法，初始化程序将 ${bit}_s$ 初始化为 1，将 ${bit}_r$ 初始化为 0，并确保没有标签为 0 或 1 的帧在传输中。然后初始化程序通知发送方开始获取消息。

Surprisingly, as we now show, no such initialization procedure exists.

令人惊讶的是，如我们现在所示，没有这样的初始化程序存在。

Consider an execution in which crashes can also be possible steps; in particular, we denote the sender crash by ${Crash}_S$ and the receiver crash by ${Crash}_R$. The effect of a crash step ${Crash}_X$ is an initialization of the state of the processor $X$ to a special after-crash state. Thus, all the information that $X$ encoded in its state before the crash is totally lost.

考虑一个执行，其中崩溃也可能是可能的步骤；特别是，我们将发送方崩溃表示为 ${Crash}_S$，接收方崩溃表示为 ${Crash}_R$。崩溃步骤 ${Crash}_X$ 的效果是将处理器 $X$ 的状态初始化为特殊的崩溃后状态。因此，$X$ 在崩溃前其状态中编码的所有信息都完全丢失。

We first consider an execution $E$ that starts in a system configuration in which no frames are in transit and in which both $S$ and $R$ are in the special after-crash state. No frame is lost during $E$ and every frame arrives at its destination before the next frame is sent. For example, if the first frame sent following the crash from the sender to the receiver is $f_{s1}$, then $f_{s1}$ arrives at its destination and the receiver sends $f_{r1}$ as a reaction. This nice "ping-pong" execution is executed until the sender fetches the second message to be sent from the network layer. We denote such an execution by: $E = {Crash}_S$, ${Crash}_R$, ${send}_S(f_{s1})$, ${receive}_R(f_{s1})$, ${send}_R(f_{r1})$, ${receive}_S(f_{r1})$, ${send}_S(f_{s2})$, ···, ${receive}_S(f_{rk})$. We use the term *reference execution* for $E$. The frame $f_{rk}$ received by the sender during $E$ is the one that convinces the sender in the reference execution to fetch the next message from the network layer.

我们首先考虑一个执行 $E$，它从一个没有帧在传输中的系统配置开始，并且 $S$ 和 $R$ 都处于特殊的崩溃后状态。在 $E$ 期间没有帧丢失，每个帧在下一个帧发送之前到达其目的地。例如，如果崩溃后从发送方发送到接收方的第一个帧是 $f_{s1}$，那么 $f_{s1}$ 到达其目的地，接收方作为反应发送 $f_{r1}$。这种良好的“乒乓”执行一直进行到发送方获取要从网络层发送的第二条消息。我们将这种执行表示为：$E = {Crash}_S$, ${Crash}_R$, ${send}_S(f_{s1})$, ${receive}_R(f_{s1})$, ${send}_R(f_{r1})$, ${receive}_S(f_{r1})$, ${send}_S(f_{s2})$, ···, ${receive}_S(f_{rk})$。我们用术语 *参考执行* 来表示 $E$。在 $E$ 期间发送方接收到的帧 $f_{rk}$ 是在参考执行中说服发送方从网络层获取下一条消息的帧。

The idea of the proof, which we call the *pumping technique*, is repeatedly to crash the sender and the receiver and to replay parts of the reference execution in order to construct a new execution $E'$. During the replay the sender fetches several messages that are identical to $m$. Note that it is possible for the network layer to use the services of the data-link layer to deliver several identical messages in a row. Figure 3.1 is used below to demonstrate the pumping technique, but first we describe the techniques in words. ${Crash}_S$ and ${Crash}_R$ occur at the beginning of our new execution $E$ ; then $f_{s1}$ is sent and arrives at the receiver, and $f_{r1}$ is sent as a reply exactly as in $E$. Now ${Crash}_S$ takes place, so we have ${Crash}_S$, ${Crash}_R$, ${send}_S(f_{s1})$, ${receive}_R(f_{s1})$, ${send}_R(f_{r1})$, ${Crash}_S$. At the end of the above execution, the sender is in an after-crash state and, according to $E$, is ready to send $f_{s1}$. We let the sender send $f_{s1}$ before it receives $f_{r1}$.

证明的思想，我们称之为 *抽水技术*，是反复使发送方和接收方崩溃，并重放参考执行的部分，以构建一个新的执行 $E'$。在重放期间，发送方获取几条与 $m$ 相同的消息。请注意，网络层可以使用数据链路层的服务连续传递几条相同的消息。图 3.1 用于下面演示抽水技术，但首先我们用文字描述这些技术。${Crash}_S$ 和 ${Crash}_R$ 发生在我们新执行 $E$ 的开始；然后 $f_{s1}$ 被发送并到达接收方，$f_{r1}$ 被发送作为回复，正如在 $E$ 中一样。现在发生 ${Crash}_S$，所以我们有 ${Crash}_S$, ${Crash}_R$, ${send}_S(f_{s1})$, ${receive}_R(f_{s1})$, ${send}_R(f_{r1})$, ${Crash}_S$。在上述执行结束时，发送方处于崩溃后的状态，并且根据 $E$，准备发送 $f_{s1}$。我们让发送方在接收到 $f_{r1}$ 之前发送 $f_{s1}$。

In this configuration, the content of the queue $q_{s,r}$ of frames transmitted over the link from the sender to the receiver is $f_{s1}$, and the content of the queue $q_{r,s}$ of frames transmitted over the link from the receiver to the sender is $f_{r1}$. Moreover, the sender is in a state in which $f_{s1}$ was already sent and is now ready to receive $f_{r1}$.

在这种配置中，通过链路从发送方传输到接收方的帧队列 $q_{s,r}$ 的内容是 $f_{s1}$，通过链路从接收方传输到发送方的帧队列 $q_{r,s}$ 的内容是 $f_{r1}$。此外，发送方处于已发送 $f_{s1}$ 并准备接收 $f_{r1}$ 的状态。

We let the sender receive the frame $f_{r1}$ that is in $q_{r,s}$ and, since the sender is deterministic, it sends frame $f_{s2}$ as a reaction, exactly as in the reference execution $E$. Up to this stage, we have constructed the execution ${Crash}_S$, ${Crash}_R$, ${send}_S(f_{s1})$, ${receive}_R(f_{s1})$, ${send}_R(f_{r1})$, ${Crash}_S$, ${send}_S(f_{s1})$, ${receive}_S(f_{r1})$, ${send}_S(f_{s2})$. The contents of $q_{s,r}$ in the configuration that is reached at the end of the above execution are $f_{s1}$, $f_{s2}$, where $f_{s1}$ is the first frame to reach the receiver. We extend the execution, crashing $R$ and letting it receive $f_{s1}$ and send $f_{r1}$, receive $f_{s2}$ and send $f_{r2}$. Now the execution is ${Crash}_S$, ${Crash}_R$, ${send}_S(f_{s1})$, ${receive}_R(f_{s1})$, ${send}_R(f_{r1})$, ${Crash}_S$, ${send}_S(f_{s1})$, ${receive}_S(f_{r1})$, ${send}_S(f_{s2})$, ${Crash}_R$, ${receive}_R(f_{s1})$, ${send}_R(f_{r1})$, ${receive}_R(f_{s2})$, ${send}_R(f_{r2})$. Thus, we reach a configuration in which the contents of $q_{r,s}$ are $f_{r1}$, $f_{r2}$.

我们让发送方接收在 $q_{r,s}$ 中的帧 $f_{r1}$，由于发送方是确定性的，它发送帧 $f_{s2}$ 作为反应，正如在参考执行 $E$ 中一样。到目前为止，我们已经构建了执行 ${Crash}_S$, ${Crash}_R$, ${send}_S(f_{s1})$, ${receive}_R(f_{s1})$, ${send}_R(f_{r1})$, ${Crash}_S$, ${send}_S(f_{s1})$, ${receive}_S(f_{r1})$, ${send}_S(f_{s2})$。在上述执行结束时达到的配置中，$q_{s,r}$ 的内容是 $f_{s1}$, $f_{s2}$，其中 $f_{s1}$ 是第一个到达接收方的帧。我们扩展执行，使 $R$ 崩溃并让它接收 $f_{s1}$ 并发送 $f_{r1}$，接收 $f_{s2}$ 并发送 $f_{r2}$。现在执行是 ${Crash}_S$, ${Crash}_R$, ${send}_S(f_{s1})$, ${receive}_R(f_{s1})$, ${send}_R(f_{r1})$, ${Crash}_S$, ${send}_S(f_{s1})$, ${receive}_S(f_{r1})$, ${send}_S(f_{s2})$, ${Crash}_R$, ${receive}_R(f_{s1})$, ${send}_R(f_{r1})$, ${receive}_R(f_{s2})$, ${send}_R(f_{r2})$。因此，我们达到了 $q_{r,s}$ 的内容是 $f_{r1}$, $f_{r2}$ 的配置。

Let $X$ denote either $S$ or $R$, where $Y$ denotes $S$ if $X$ denotes $R$ and $Y$ denotes $R$ if $X$ denotes $S$. In general, we start in a configuration in which all frames sent by $X$ in a prefix of the execution $E$ are in $q_{X,Y}$. We crash $Y$ and let it produce a sequence of frames that it produces in a prefix of $E$ while accepting the frames in $q_{X,Y}$. We then continue crashing $X$ and using the frames in $q_{Y,X}$ in a similar way. With the pumping technique, the length of the prefix of $E$ that is executed by the sender and the receiver grows with the number of crashes.

令 $X$ 表示 $S$ 或 $R$，其中如果 $X$ 表示 $R$，则 $Y$ 表示 $S$，如果 $X$ 表示 $S$，则 $Y$ 表示 $R$。通常，我们从一个配置开始，其中 $X$ 在执行 $E$ 的前缀中发送的所有帧都在 $q_{X,Y}$ 中。我们使 $Y$ 崩溃，并让它在接受 $q_{X,Y}$ 中的帧时生成它在 $E$ 的前缀中生成的帧序列。然后我们继续使 $X$ 崩溃，并以类似的方式使用 $q_{Y,X}$ 中的帧。通过抽水技术，发送方和接收方执行的 $E$ 的前缀长度随着崩溃次数的增加而增长。

![figure_3.1](images/figure_3.1.png)

Continuing in the same way, we pump the contents of $q_{r,s}$ until it contains $f_{r1}, f_{r2}, ···, f_{rk}$. Then we crash both the sender and the receiver and let the sender receive all the frames in $q_{r,s}$; this, in turn, convinces the sender that the message was sent so that it fetches a new message from the network layer. Now if all frames sent from the sender to the receiver are lost, then no information concerning the first message exists in the system. Therefore, we conclude that the first message that was fetched following the last crash is lost, which proves the impossibility result.

以同样的方式继续，我们抽取 $q_{r,s}$ 的内容，直到它包含 $f_{r1}, f_{r2}, ···, f_{rk}$。然后我们使发送方和接收方都崩溃，并让发送方接收 $q_{r,s}$ 中的所有帧；这反过来使发送方相信消息已发送，从而从网络层获取新消息。现在，如果发送方发送到接收方的所有帧都丢失，那么系统中不存在关于第一条消息的任何信息。因此，我们得出结论，最后一次崩溃后获取的第一条消息丢失了，这证明了不可能性结果。

In figure 3.1, we present the eight configurations to describe the pumping technique. Configuration 1 follows a crash of $S$ and the transmission of $f_{s1}$. Configuration 2 is derived from the first configuration by steps of $R$ in which $R$ receives $f_{s1}$, sends $f_{r1}$, and then crashes. Configuration 3 is derived from configuration 2 by steps of $S$ in the following order: a crash of $S$, a send of $f_{s1}$, a receive of $f_{r1}$, and a send of $f_{s2}$. In general, the even-numbered configurations are reached from the odd-numbered ones by a crash of $R$, then receipt of the pending frames of the previous odd-numbered configuration, while sending responses. The odd-numbered configurations are reached from the even-numbered ones by a crash of $S$, then a spontaneous send of frame $f_{s1}$, followed by receipt of the pending messages of the odd-numbered configuration while sending responses.

在图 3.1 中，我们展示了描述抽水技术的八种配置。配置 1 是在 $S$ 崩溃和传输 $f_{s1}$ 之后。配置 2 是通过 $R$ 的步骤从第一个配置派生出来的，其中 $R$ 接收 $f_{s1}$，发送 $f_{r1}$，然后崩溃。配置 3 是通过 $S$ 的步骤从配置 2 派生出来的，顺序如下：$S$ 崩溃，发送 $f_{s1}$，接收 $f_{r1}$，然后发送 $f_{s2}$。一般来说，偶数配置是通过 $R$ 崩溃，然后接收前一个奇数配置的待处理帧，同时发送响应来实现的。奇数配置是通过 $S$ 崩溃，然后自发发送帧 $f_{s1}$，接着接收奇数配置的待处理消息，同时发送响应来实现的。

We note that the pumping technique can also be used when the first frame sent after the crashes in the reference execution is a frame sent by the receiver, or when several frames are sent by the sender (or the receiver) before an answer is sent by the other side. The details are left as an exercise to the reader.

我们注意到，当参考执行中的崩溃后发送的第一个帧是接收方发送的帧，或者在另一方发送响应之前发送方（或接收方）发送了多个帧时，也可以使用抽水技术。细节留给读者作为练习。

By similar arguments, it is also possible to show that there is no guarantee that the kth message that is fetched following the last crash will be received. So if no specific guarantee can be given, we may want to require that eventually every message fetched by the sender reaches the receiver — in other words, to require that our data-link algorithm will be self-stabilizing.

通过类似的论证，还可以证明无法保证最后一次崩溃后获取的第 k 条消息会被接收。因此，如果不能给出具体的保证，我们可能希望要求最终发送方获取的每条消息都能到达接收方——换句话说，要求我们的数据链路算法是自稳定的。
