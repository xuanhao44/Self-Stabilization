# 4.1 Token-Passing: Converting a Central Daemon to read/write

The literature in self-stabilization is rich in algorithms that assume the existence of powerful schedulers, the *distributed daemon* or the *central daemon*. The distributed daemon activates the processors by repeatedly selecting a set of processors and activating them simultaneously to execute a computation step. Each processor executes the next computation step as defined by its state just prior to this activation. We use read and write operations to describe precisely the meaning of the simultaneous execution of the computation steps. Simultaneous execution starts with all the activated processors reading the states of their neighbors. Once every processor in the set has finished reading, all the processors write a new state (change state). Only then does the scheduler choose a new set of processors to be activated. Note that no non-activated processor changes its state. The central daemon is a special case of the distributed daemon in which the set of activated processors consists of exactly one processor. Note that a synchronous system in which all the processors are activated in every step is also a special case of a system with a distributed daemon.

自稳定性文献中有许多假设存在强大调度程序的算法，如 *分布式守护进程* 或 *中央守护进程*。分布式守护进程通过反复选择一组处理器并同时激活它们来执行计算步骤。每个处理器执行在此激活之前由其状态定义的下一个计算步骤。我们使用读写操作来精确描述计算步骤同时执行的含义。同步执行从所有激活的处理器读取其邻居的状态开始。一旦集合中的每个处理器完成读取，所有处理器写入新状态（改变状态）。只有这样，调度程序才会选择一组新的处理器进行激活。请注意，未激活的处理器不会改变其状态。中央守护进程是分布式守护进程的一种特殊情况，其中激活的处理器组仅包含一个处理器。请注意，在每一步中激活所有处理器的同步系统也是具有分布式守护进程的系统的一种特殊情况。

What are the reasons for using the above special settings in the literature on self-stabilization? One reason is the choices Dijkstra made in the first work in the field. Another is the inherent subtlety of designing self-stabilizing algorithms, which can be started in any possible configuration. The assumption of the existence of a daemon enables the designer to consider only a subset of the possible execution set. In particular, there is no need to use internal variables to store the values read from the communication registers (or to consider the values of these internal variables as subject to corruption by transient faults as well).

在自稳定性文献中使用上述特殊设置的原因是什么？一个原因是 Dijkstra 在该领域的第一项工作中做出的选择。另一个原因是设计自稳定算法的内在微妙性，这些算法可以从任何可能的配置开始。假设守护进程的存在使设计者可以只考虑可能执行集的一个子集。特别是，不需要使用内部变量来存储从通信寄存器读取的值（或将这些内部变量的值视为也可能受到瞬态故障的破坏）。

The great importance of relaxing the assumption concerning the schedule pattern is obvious. An algorithm designed to work in read/write atomicity can be used in any system in which there exists a central or a distributed daemon, while an algorithm designed for a system with a central or a distributed daemon cannot be used in a system that supports only read/write atomicity. The above facts are our motivation for designing a compiler that receives as an input a self-stabilizing algorithm $\mathcal{AL}$ for some task $\mathcal{T}$ that is designed for systems with the central or distributed daemon, and outputs a version of $\mathcal{AL}$ for task $\mathcal{T}$ for systems that support only read/write atomicity. An algorithm designed to stabilize in the presence of a distributed daemon must stabilize in a system with a central daemon — one possible policy of the distributed daemon is to activate one processor at a time, and an algorithm designed to stabilize under any scheduling policy of the distributed daemon must stabilize when one processor is activated at a time. In this section, we suggest distributively implementing a central daemon by a self-stabilizing mutual exclusion or token-passing algorithm. When a processor enters the critical section in the mutual exclusion algorithm, or when a processor holds the token in the token-passing algorithm, it reads the states of its neighbors and changes state accordingly. Once the processor changes its state, it exits the critical section or passes the token.

放宽关于调度模式的假设的重要性显而易见。设计用于读/写原子性的算法可以在存在中央或分布式守护进程的任何系统中使用，而设计用于具有中央或分布式守护进程的系统的算法不能在仅支持读/写原子性的系统中使用。上述事实是我们设计编译器的动机，该编译器接收为具有中央或分布式守护进程的系统设计的某个任务 $\mathcal{T}$ 的自稳定算法 $\mathcal{AL}$ 作为输入，并输出仅支持读/写原子性的系统的任务 $\mathcal{T}$ 的 $\mathcal{AL}$ 版本。设计用于在分布式守护进程存在下稳定的算法必须在具有中央守护进程的系统中稳定——分布式守护进程的一种可能策略是一次激活一个处理器，而设计用于在分布式守护进程的任何调度策略下稳定的算法必须在一次激活一个处理器时稳定。在本节中，我们建议通过自稳定互斥或令牌传递算法分布式地实现中央守护进程。当处理器进入互斥算法的临界区，或当处理器在令牌传递算法中持有令牌时，它读取其邻居的状态并相应地改变状态。一旦处理器改变其状态，它就退出临界区或传递令牌。

The algorithm is designed for a system with an arbitrary communication graph and a single special processor. In what follows, we show how the assumption on the existence of a special processor can be achieved by using a self-stabilizing leader-election algorithm.

该算法设计用于具有任意通信图和单个特殊处理器的系统。在下文中，我们将展示如何通过使用自稳定的领导者选举算法来实现对特殊处理器存在的假设。

We use the algorithm presented in section 2.7, which uses the fair-composition technique to compose the spanning-tree-construction algorithm of section 2.5 with the read/write atomicity version of Dijkstra's mutual exclusion algorithm in section 2.6. Once the spanning-tree construction algorithm stabilizes, a virtual ring forming the Euler tour on the spanning tree is distributively defined. Moreover, the root of the tree acts as the special processor in the ring. Thus, when the mutual exclusion algorithm stabilizes, it is the case that exactly one processor may enter the critical section in every configuration. A processor that enters the critical section of the mutual exclusion algorithm reads the state of its neighbors (or the portion of the state that is communicated to it through the communication registers), changes state and new state to its communication registers, and then exits the critical section. Note that every time a processor enters the critical section it executes a constant number of steps and then exits. Therefore, the convergence of the mutual exclusion algorithm to a safe configuration is still guaranteed.

我们使用第 2.7 节中介绍的算法，该算法使用公平组合技术将第 2.5 节的生成树构造算法与第 2.6 节中 Dijkstra 互斥算法的读/写原子性版本组合在一起。一旦生成树构造算法稳定下来，在生成树上形成欧拉环的虚拟环就被分布式定义。此外，树的根在环中充当特殊处理器。因此，当互斥算法稳定时，每个配置中恰好有一个处理器可以进入临界区。进入互斥算法临界区的处理器读取其邻居的状态（或通过通信寄存器传递给它的状态部分），改变状态并将新状态写入其通信寄存器，然后退出临界区。请注意，每次处理器进入临界区时，它执行固定数量的步骤，然后退出。因此，互斥算法收敛到安全配置仍然有保证。

Our compiler receives as input an algorithm $\mathcal{AL}$ that stabilizes in the presence of a central daemon and composes it with a self-stabilizing mutual exclusion algorithm that schedules the operations of the processors. In an arbitrary initial configuration of the composed algorithm, it is possible that more than a single processor is scheduled to execute a step in $\mathcal{AL}$. Therefore, while the mutual exclusion algorithm stabilizes, it is possible that two neighboring processors will change state simultaneously. Therefore, $\mathcal{AL}$ may not converge to a safe configuration until the mutual exclusion algorithm stabilizes. In fact, however, we are not interested in its exact behavior during this period, since it does not interfere with the activity of the mutual exclusion algorithm. When the mutual exclusion algorithm reaches a safe configuration, the state portion of the processors that is related to $\mathcal{AL}$ is arbitrary. Fortunately, $\mathcal{AL}$ converges to a safe configuration from any arbitrary configuration when it is activated by the central daemon.

我们的编译器接收一个在中央守护进程存在下稳定的算法 $\mathcal{AL}$ 作为输入，并将其与调度处理器操作的自稳定互斥算法组合。在组合算法的任意初始配置中，可能会有多个处理器被调度执行 $\mathcal{AL}$ 的步骤。因此，在互斥算法稳定期间，可能会有两个相邻的处理器同时改变状态。因此，在互斥算法稳定之前，$\mathcal{AL}$ 可能不会收敛到安全配置。然而，事实上，我们并不关心其在此期间的确切行为，因为它不会干扰互斥算法的活动。当互斥算法达到安全配置时，与 $\mathcal{AL}$ 相关的处理器状态部分是任意的。幸运的是，当由中央守护进程激活时，$\mathcal{AL}$ 可以从任何任意配置收敛到安全配置。
