# 3.3 Frequently Asked Questions

To further motivate self-stabilizing algorithms we must answer several important frequently asked questions. One such question is: what is the rationale behind assuming that the states of the processors (the contents of their memory) can be corrupted while the processors' programs cannot be corrupted? After all, the program is usually loaded in exactly the same memory device used to store the content of the program variables. Note that a self-stabilizing algorithm is design to cope with the corruption of variables (including corruption of the value of the program counter) but not with a corruption of the program code. The answer to the above question uses two arguments. The first is that usually the (backup copy of the) program of the processors is stored in a long-term memory device, such as a hard drive, from which it is possible periodically to reload the program statements in order to overcome a possible memory corruption. In addition, in some cases the program is hardwired in a read-only memory device that cannot be corrupted by faults that corrupt the random-access memory contents. The second argument is related to the necessity of having an uncorrupted copy of the program (either in a secondary memory device or in hardware). Let us assume that the program is subject to corruptions as well. In such cases it is impossible to reason about the actions of the processors that have a corrupted code. In fact (as explained in chapter 6), it is possible to cope with only a very limited number of processors that execute corrupted programs.

为了进一步激励自稳定算法，我们必须回答几个重要的常见问题。其中一个问题是：为什么假设处理器的状态（其内存的内容）可能被破坏，而处理器的程序不能被破坏？毕竟，程序通常加载在用于存储程序变量内容的同一个内存设备中。请注意，自稳定算法旨在应对变量的破坏（包括程序计数器值的破坏），但不应对程序代码的破坏。上述问题的答案有两个论点。首先，处理器的程序（备份副本）通常存储在长期存储设备中，例如硬盘，可以定期重新加载程序语句以克服可能的内存破坏。此外，在某些情况下，程序被硬连线在只读存储设备中，不会被破坏随机存取内存内容的故障破坏。第二个论点与拥有未损坏的程序副本（无论是在辅助存储设备中还是在硬件中）的必要性有关。假设程序也会受到破坏。在这种情况下，不可能推理出具有损坏代码的处理器的操作。事实上（如第 6 章所述），只能应对执行损坏程序的极少数处理器。

Another frequently asked question is related to the safety properties of a self-stabilizing algorithm. Usually a distributed algorithm is designed to satisfy safety and liveness properties, where (roughly speaking) safety properties ensures that the system never reaches a bad configuration and the liveness property ensures that the system eventually achieves its goal. The assumption made by the designer of self-stabilizing algorithms is that the algorithm must converge from every possible initial configuration, thus ensuring that, even if a safety requirement is violated, the system execution will reach a suffix in which both the safety and liveness properties hold. At first glance, it seems that the violation of a safety property is a weakness in the self-stabilizing property — what use is an algorithm that does not ensure that a car (controlled by this algorithm) never crashes? This question confuses the severe conditions that a self-stabilizing algorithm assumes with the properties the algorithm achieves. In other words, it is clear that no algorithm can cope with (a set of faults that force it to) any possible initial state and still ensure that certain configurations will never be reached. Thus, if the faults are severe enough to make the algorithm reach an arbitrary configuration, the car may crash no matter what algorithm is chosen. Algorithm designers assume an initial state in which several properties hold and assume that the transitions of the system do not violate these properties; they do not concern themselves with the behavior of the system once these safety properties are violated. A safety property for a car controller might be: never turn into a one-way road when there is no “enter” sign. Thus, if faults cause the car to enter the wrong way on a one-way road, the actions the controller takes are not defined. When no specification exists, the car can continue driving in this road and crash with other cars. On the other hand, a self-stabilizing controller will recover from this non-legal initial configuration (turn the car) and ensure that the safety property (make no further turns in the wrong direction) will hold (as long as no additional unexpected faults occur).

另一个常见问题与自稳定算法的安全性属性有关。通常，分布式算法设计用于满足安全性和活性属性，其中（粗略地说）安全性属性确保系统永远不会达到错误配置，而活性属性确保系统最终实现其目标。自稳定算法设计者假设算法必须从每个可能的初始配置收敛，从而确保即使违反了安全性要求，系统执行也会达到一个后缀，在该后缀中安全性和活性属性都成立。乍一看，违反安全性属性似乎是自稳定性属性的一个弱点——一个不能确保汽车（由该算法控制）永不撞车的算法有什么用？这个问题混淆了自稳定算法假设的严苛条件与算法实现的属性。换句话说，很明显，没有算法能够应对（迫使其进入）任何可能的初始状态，并且仍然确保某些配置永远不会被达到。因此，如果故障足够严重，使算法达到任意配置，无论选择什么算法，汽车都可能会撞车。算法设计者假设初始状态中有几个属性成立，并假设系统的转换不会违反这些属性；他们不关心一旦这些安全属性被违反，系统的行为。汽车控制器的安全属性可能是：在没有“进入”标志时，永远不要进入单行道。因此，如果故障导致汽车进入单行道的错误方向，控制器采取的行动未定义。当没有规范时，汽车可以继续在这条路上行驶并与其他汽车相撞。另一方面，自稳定控制器将从这种非法初始配置中恢复（转动汽车），并确保安全属性（不再错误转向）成立（只要没有额外的意外故障发生）。

The last question we discuss is related to the fact that processors can never be sure that a safe configuration is reached. What use is an algorithm in which the processors are never sure about the current global state? For instance, when the task is mutual exclusion, processors that enter the critical section cannot be sure that no other processor is in that critical section. This question again confuses the assumptions (transient fault occurrences) with the (self-stabilizing) algorithm that is designed to fit the severe assumptions. A self-stabilizing algorithm can be designed to start in a particular (safe) configuration. As long as the algorithm is started in the above predefined initial configuration and no (transient) fault occurs, each processor‘s knowledge about the system is accurate. Thus, a self-stabilizing algorithm is at least as good as a non-self-stabilizing algorithm for the same task. In our example, a processor that enters the critical section can be sure that no other processor is in the critical section. Moreover, when a fault does occur, the knowledge of each processor will be eventually accurate. In the terms of our example, a processor knows that *eventually* it will enter the critical section by itself (assuming faults do not occur too often).

最后一个问题与处理器永远无法确定已达到安全配置这一事实有关。一个算法在处理器永远无法确定当前全局状态的情况下有什么用？例如，当任务是互斥时，进入临界区的处理器无法确定没有其他处理器在该临界区。这个问题再次混淆了假设（瞬态故障发生）与设计用于适应这些严苛假设的（自稳定）算法。自稳定算法可以设计为从特定的（安全）配置开始。只要算法在上述预定义的初始配置中启动，并且没有（瞬态）故障发生，每个处理器对系统的了解都是准确的。因此，对于相同的任务，自稳定算法至少与非自稳定算法一样好。在我们的例子中，进入临界区的处理器可以确定没有其他处理器在临界区。此外，当发生故障时，每个处理器的知识最终会准确。根据我们的例子，处理器知道 *最终* 它将独自进入临界区（假设故障不太频繁发生）。
