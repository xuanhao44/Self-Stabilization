# 2.1 Definitions of the Computational Model

The term *distributed system* is used to describe communication networks, multiprocessor computers, and a multitasking single computer. All the above variants of distributed systems have similar fundamental coordination requirements among the communicating entities, whether they are computers, processors, or processes. Thus **an abstract model** that **ignores the specific setting** and captures the important characteristics of a distributed system is usually employed.

*分布式系统* 一词用于描述通信网络、多处理器计算机和多任务单计算机。上述所有分布式系统的变体在通信实体（无论是计算机、处理器还是进程）之间都有类似的基本协调需求。因此，通常采用一种**忽略具体设置**并捕捉分布式系统重要特征的**抽象模型**。

Each computer runs a program composed of executable statements. Each execution of a statement changes the content of the computer’s local memory, including the program counter. In other words, the computer changes state with each statement execution. An abstract way to model a computer that executes a program is to use the state machine model. **A distributed system is modeled by a set of $n$ state machines called processors that communicate with each other. We usually denote the $i$ th processor in the system by $P_i$ . Each processor can communicate with other processors, called its neighbors.** It is convenient to represent a distributed system by a communication graph in which each processor is represented by a node and every two neighboring processors are connected by a link of the communication graph.

每台计算机运行由可执行语句组成的程序。每次执行语句都会改变计算机本地内存的内容，包括程序计数器。换句话说，计算机在每次语句执行时都会改变状态。抽象地说，执行程序的计算机可以用状态机模型来表示。**分布式系统由一组称为处理器的 $n$ 个状态机组成，它们相互通信。我们通常用 $P_i$ 表示系统中的第 $i$ 个处理器。每个处理器可以与其他处理器（称为其邻居）通信。**用通信图表示分布式系统是很方便的，其中每个处理器用一个节点表示，每两个相邻的处理器通过通信图的一个链接连接。

**The communication between neighboring processors can be carried out by message passing or shared memory. Communication by writing in, and reading from, the shared memory usually fits systems with processors that are geographically close together, such as multiprocessor computers or processes executed by a multitasking single-processor computer. A message-passing distributed model fits both processors that are located close to each other and wide-area distributed systems, such as communication networks.**

**相邻处理器之间的通信可以通过消息传递或共享内存进行。通过写入和读取共享内存进行通信通常适用于地理位置接近的处理器系统，例如多处理器计算机或由多任务单处理器计算机执行的进程。消息传递分布式模型适用于彼此靠近的处理器和广域分布式系统，例如通信网络。**

In the message-passing model, neighbors communicate by sending and receiving messages. In asynchronous distributed systems, the speed of processors and message transmission can vary. First-in first-out (FIFO) queues are used to model asynchronous delivery of messages. A communication link is either unidirectional or bidirectional. **A unidirectional communication link from processor $P_i$ to processor $P_j$ transfers messages from $P_i$ to $P_j$ . The abstraction used for such a unidirectional link is a first-in first-out (FIFO) queue $q_{i,j}$ , that contains all messages sent by a processor $P_i$ to its neighbor $P_j$ that have not yet been received.** Whenever $P_i$ sends a message $m$ to $P_j$, the message is enqueued (added to the tail of the queue). $P_j$ may receive the message $m$ that is at the head of the queue; in such a case, the message $m$ is dequeued (removed from the front of the queue). The bidirectional communication link between processors $P_i$ and $P_j$ is modeled by two FIFO queues, one from $P_i$ to $P_j$ and the other from $P_j$ to $P_i$.

在消息传递模型中，相邻节点通过发送和接收消息进行通信。在异步分布式系统中，处理器的速度和消息传输的速度可以有所不同。先进先出（FIFO）队列用于模拟消息的异步传递。通信链路可以是单向的或双向的。**从处理器 $P_i$ 到处理器 $P_j$ 的单向通信链路将消息从 $P_i$ 传输到 $P_j$。用于这种单向链路的抽象是先进先出（FIFO）队列 $q_{i,j}$，它包含了所有由处理器 $P_i$ 发送给其邻居 $P_j$ 但尚未被接收的消息。**每当 $P_i$ 向 $P_j$ 发送消息 $m$ 时，该消息会被入队（添加到队列的尾部）。$P_j$ 可以接收位于队列头部的消息 $m$；在这种情况下，消息 $m$ 会被出队（从队列的前端移除）。处理器 $P_i$ 和 $P_j$ 之间的双向通信链路由两个 FIFO 队列建模，一个从 $P_i$ 到 $P_j$，另一个从 $P_j$ 到 $P_i$。

It is very convenient to identify the state of a computer or a distributed system at a given time, so that no additional information about the past of the computation is needed in order to predict the future behavior (state transitions) of the computer or the distributed system. **A full description of a message passing distributed system at a particular time consists of the state of every processor and the content of every queue (messages pending in the communication links). The term *system configuration* (or *configuration*) is used for such a description.** A configuration is denoted by $c = (s_1, s_2, ..., s_n, q_{1,2}, q_{1,3}, ..., q_{i,j}, ..., q_{n-1,n})$, where $s_i$, $1 ≤ i ≤ n$, is the state of $P_i$ and $q_{i,j}$, $i ≠ j$, is the queue of messages sent by $P_i$ to $P_j$ but not yet received.

在某个特定时间识别计算机或分布式系统的状态非常方便，这样就不需要额外的信息来预测计算机或分布式系统的未来行为（状态转换）。**在特定时间对消息传递分布式系统的完整描述包括每个处理器的状态和每个队列的内容（通信链路中未处理的消息）。这种描述称为系统配置（或配置）。**配置表示为 $c = (s_1, s_2, ..., s_n, q_{1,2}, q_{1,3}, ..., q_{i,j}, ..., q_{n-1,n})$，其中 $s_i$，$1 ≤ i ≤ n$，是 $P_i$ 的状态，$q_{i,j}$，$i ≠ j$，是 $P_i$ 发送给 $P_j$ 但尚未接收的消息队列。

**In the shared memory model, processors communicate by the use of shared communication registers (hereafter *registers*). Processors may write in a set of registers and may read from a possibly different set of registers. The configuration of the system consists of the state of all processors and the contents of the registers.** A configuration with $n$ processors and $m$ communication registers is denoted by $c = (s_1, s_2, ..., s_n; r_1, r_2, ..., r_m)$, where $s_i$, $1 ≤ i ≤ n$, is the state of $P_i$ and for $1 ≤ j ≤ m$, $r_j$ is the contents of a communication register.

**在共享内存模型中，处理器通过使用共享通信寄存器（以下简称 *寄存器*）进行通信。处理器可以写入一组寄存器，并且可以从可能不同的一组寄存器中读取。系统的配置包括所有处理器的状态和寄存器的内容。**具有 $n$ 个处理器和 $m$ 个通信寄存器的配置表示为 $c = (s_1, s_2, ..., s_n; r_1, r_2, ..., r_m)$，其中 $s_i$，$1 ≤ i ≤ n$，是 $P_i$ 的状态，对于 $1 ≤ j ≤ m$，$r_j$ 是通信寄存器的内容。

The future state transitions of a stand-alone computer that executes a (non-interactive) program can be deterministically predicted from its current state. Note that, for a stand-alone computer, the speed of the state transitions may not be fixed (in a multitasking computer environment, the period of time for which each task is executed may change over time); nevertheless, when the tasks are totally independent, we can predict the state of each task following the $i$ th state transition of this task. The situation in distributed systems is different. Nondeterminism due to different speeds of processors and of message delivery can result in totally different state transitions of processors from identical initial states. For example, a processor waiting to receive messages from one of each of its neighbors may act differently if a message from neighbor $P_i$ arrives before a message from $P_j$ , or vice versa. **In other words, scheduling of events in a distributed system influences the transitions made by the processors. The situation is even more complicated, since processors execute program statements in parallel at different rates.**

执行（非交互式）程序的独立计算机的未来状态转换可以从其当前状态确定性地预测。注意，对于独立计算机，状态转换的速度可能不是固定的（在多任务计算机环境中，每个任务执行的时间段可能会随时间变化）；尽管如此，当任务完全独立时，我们可以在该任务的第 $i$ 次状态转换后预测每个任务的状态。分布式系统中的情况则不同。由于处理器和消息传递速度的不同导致的不确定性可能会导致处理器从相同的初始状态进行完全不同的状态转换。例如，一个处理器等待从每个邻居接收消息时，如果来自邻居 $P_i$ 的消息先于来自 $P_j$ 的消息到达，或者反之亦然，它可能会有不同的行为。换句话说，**分布式系统中事件的调度会影响处理器的转换。情况更加复杂，因为处理器以不同的速率并行执行程序语句。**

**The interleaving model is used to reason about the behavior of the distributed system.** In this model it is assumed that, at each given time, only a single processor executes a *computation step* (also called an *atomic step*). **Each computation step consists of internal computation and a single communication operation: a send or receive in message passing systems and a write or read in shared memory systems.** Note that a computation step may consist of local computations (e.g., subtraction of the values of two local registers of the processors) in addition to the communication operation. Without loss of generality, the time at which all the local operations between two communication operations of a processor occur is assumed to be immediately before the second communication operation. Thus, **it is possible to assume that every state transition of a process is due to communication-step execution** (including all local computations that follow the previous step and precede the communication operation of the computation step).

**交错模型用于推理分布式系统的行为。**在该模型中，假设在每个给定时间，只有一个处理器执行一个 *计算步骤*（也称为 *原子步骤*）。**每个计算步骤包括内部计算和一个通信操作：在消息传递系统中是发送或接收，在共享内存系统中是写入或读取。**注意，计算步骤除了通信操作外，还可能包括本地计算（例如，处理器的两个本地寄存器值的减法）。在不失一般性的情况下，假设处理器的两个通信操作之间的所有本地操作发生的时间是紧接在第二个通信操作之前。因此，**可以假设进程的每个状态转换都是由于通信步骤的执行**（包括所有在前一步之后和计算步骤的通信操作之前的本地计算）。

Note that **a distributed system allows the processors to execute steps concurrently**; however, **when processors execute steps concurrently we assume that there is no influence of one step on the other**. This is clearly true for send and receive operations that are executed simultaneously, because a message sent cannot be received by a receive operation that is executed at the same time. As for shared memory, it is assumed that the communication register architecture guarantees serialization: the read and write operations can be ordered in a total order such that the result of a read operation from some register is the value that was written last before this read (according to the total order) in that register.

请注意，**分布式系统允许处理器并发执行步骤**；然而，**当处理器并发执行步骤时，我们假设一个步骤不会对另一个步骤产生影响。**这对于同时执行的发送和接收操作显然是正确的，因为发送的消息不能被同时执行的接收操作接收。对于共享内存，假设通信寄存器架构保证了序列化：读和写操作可以按总顺序排列，使得从某个寄存器进行的读操作的结果是该寄存器中在此读操作之前最后写入的值（根据总顺序）。

In what follows, we use the term *step* for a computation step and we **denote a step (together with the identity of the processor that executes it) by $a$.** Let $c_1$ and $c_2$ be two configurations of the system, **where $c_2$ is reached from $c_1$ by a single step $a$ of a processor; we denote this fact by $c_1 \xrightarrow{a} c_2$.** The step $a$ is *applicable* to a configuration $c$ if (and only if) there exists a configuration $c’$ such that $c \xrightarrow{a} c’$.

An execution $E = (c_1, a_1, c_2, a_2,···)$ (in the interleaving model) is **an alternating sequence of configurations and steps** such that $c_{i−1} \xrightarrow{a_{i−1}} c_i$ ($i > 1$); in other words, the configuration $c_i$ ($i > 1$) is obtained from $c_{i−1}$ by the execution of step $a_{i−1}$. For instance, if in step ai the processor $P_j$ writes the value $x$ to a register $r_k$ , then the only components that do not have identical values in $c_i$ and $c_{i+1}$ are the state of $P_j$ and the value of $r_k$ , which were changed according to $a_i$. A *fair* execution is **an execution in which every step that is applicable infinitely often is executed infinitely often**. In particular, if (infinitely often) a processor has a step to execute then the processor executes this step (infinitely often).

在下文中，我们使用术语 *步骤* 来表示计算步骤，并**用 $a$ 表示一个步骤**（以及执行该步骤的处理器的身份）。设 $c_1$ 和 $c_2$ 是系统的两个配置，**其中 $c_2$ 通过处理器的单个步骤 $a$ 从 $c_1$ 达到；我们用 $c_1 \xrightarrow{a} c_2$ 表示这一事实**。当且仅当存在一个配置 $c'$ 使得 $c \xrightarrow{a} c'$ 时，步骤 $a$ 才 *适用* 于配置 $c$。

一个执行 $E = (c_1, a_1, c_2, a_2,···)$（在交错模型中）是**配置和步骤的交替序列**，使得 $c_{i−1} \xrightarrow{a_{i−1}} c_i \, (i>1)$；换句话说，配置 $c_i \, (i>1)$ 是通过执行步骤 $a_{i−1}$ 从 $c_{i−1}$ 获得的。例如，如果在步骤 $a_i$ 中处理器 $P_j$ 将值 $x$ 写入寄存器 $r_k$，那么在 $c_i$ 和 $c_{i+1}$ 中唯一不具有相同值的组件是 $P_j$ 的状态和 $r_k$ 的值，它们根据 $a_i$ 发生了变化。*公平* 执行是指**每个无限次适用的步骤都被无限次执行的执行**。特别地，如果（无限次）一个处理器有一个步骤要执行，那么处理器就会执行这个步骤（无限次）。

In a **message-passing system**, it is possible that a message will be lost during the execution of the algorithm; the reason is unreliable communication media that may lose or corrupt messages in transit. Error-detection codes are used to identify and discard corrupted messages, and these messages can be considered lost messages. To model such systems, we extend the definition of a step to include *environment steps* of type $loss_{i,j}(m)$.

The environment step $loss_{i,j}(m)$ is applicable to a configuration $c_k$ in which the queue $q_{i,j}$ contains the message $m$. The application of $loss_{i,j}(m)$ to $c_k$ results in a configuration $c_{k+1}$ in which $m$ is **removed** from $q_{i,j}$ , and $c_k$ and $c_{k+1}$ are identical in the rest of their components.

Unlike steps executed by processors, we do not require that, in every infinite fair execution, the environment steps that are applicable infinitely often will be executed infinitely often. **We do require that, in a fair execution in which a message is sent infinitely often, the message must be received infinitely often.** To satisfy fairness the receive step must be executed infinitely often, while the loss step should not be executed infinitely often.

在**消息传递系统**中，算法执行过程中可能会丢失消息；原因是通信介质不可靠，可能会在传输过程中丢失或损坏消息。错误检测码用于识别和丢弃损坏的消息，这些消息可以被视为丢失的消息。为了对这种系统建模，我们扩展了步骤的定义，包括类型为 $loss_{i,j}(m)$ 的环境步骤。

环境步骤 $loss_{i,j}(m)$ 适用于队列 $q_{i,j}$ 包含消息 $m$ 的配置 $c_k$*将 $loss_{i,j}(m)$ 应用于 $c_k$ 会导致配置 $c_{k+1}$，其中 $m$ 从 $q_{i,j}$ 中**移除**，$c_k$ 和 $c_{k+1}$ 在其余组件中是相同的。

与处理器执行的步骤不同，我们不要求在每个无限公平执行中，无限次适用的环境步骤将被无限次执行。**我们确实要求，在一个消息无限次发送的公平执行中，该消息必须被无限次接收。**为了满足公平性，接收步骤必须被无限次执行，而丢失步骤不应被无限次执行。

Up to this stage, we have presented the class of distributed systems called *asynchronous* distributed systems. The experience of distributed algorithm designers is that algorithms designed for asynchronous systems perform well in communication networks and multiprocessor systems. **Yet there is a class of distributed algorithms designed for *synchronous* distributed systems in which a *global clock pulse* (or simply a *pulse*) triggers a simultaneous step of every processor in the system.** This class of synchronous algorithms fits multiprocessor systems in which the processors are located close to each other and can therefore be efficiently connected to a common clock pulse. Next we describe the assumptions concerning the steps of the processors in synchronous message-passing and shared-memory systems.

到目前为止，我们已经介绍了称为 *异步* 分布式系统的分布式系统类别。分布式算法设计者的经验是，为异步系统设计的算法在通信网络和多处理器系统中表现良好。然而，还有一类**为 *同步* 分布式系统设计的分布式算法**，其中 ***全局时钟脉冲*（或简称 *脉冲*）触发系统中每个处理器的同步步骤**。这类同步算法适用于处理器彼此靠近并且可以高效连接到公共时钟脉冲的多处理器系统。接下来，我们描述同步消息传递和共享内存系统中处理器步骤的假设。

The following actions are performed between each successive pulses of a synchronous message-passing system: the pulse triggers message send operations of every processor to every one of its neighbors, then every message is received by its destination. In the shared memory system, a pulse triggers each processor to read all the registers of its neighbors. Once every processor has finished reading, the processors can write into their registers. Thus, since all the processors execute a step simultaneously, **the execution of a synchronous system $E = (c_1, c_2,···)$ is totally defined by $c_1$, the first configuration in $E$.**

在同步消息传递系统的每个连续脉冲之间执行以下操作：脉冲触发每个处理器向其所有邻居发送消息操作，然后每条消息被其目的地接收。在共享内存系统中，脉冲触发每个处理器读取其所有邻居的寄存器。一旦每个处理器完成读取，处理器就可以写入它们的寄存器。因此，由于所有处理器同时执行一个步骤，**同步系统的执行 $E = (c_1, c_2,···)$ 完全由 $c_1$（即 $E$ 中的第一个配置）定义。**
