# 6 Convergence in the Presence of Faults

The focus of this chapter is the integration of self-stabilization with other fault models, such as crash failures and Byzantine failures, both of which have been studied extensively. Crash failures are failures that cause a processor to stop operating. Algorithms that tolerate crash failures in some of the processors and achieve their goal in spite of the failures are of practical interest, since processors do crash from time to time due to power supply problems, user activity, or software problems.

本章的重点是将自稳定性与其他故障模型集成，如崩溃故障和拜占庭故障，这两者都已被广泛研究。崩溃故障是指导致处理器停止运行的故障。能够容忍部分处理器崩溃并在故障发生时仍能实现其目标的算法在实际中具有重要意义，因为处理器由于电源问题、用户活动或软件问题而偶尔会崩溃。

In addition, software (and sometimes hardware) may contain flaws; therefore, the behavior of a faulty processor is not limited to ceasing to operate, as assumed in the crash-faults model. Obviously, the effect of software bugs cannot be determined in advance. How does one model the behavior of a faulty processor?

此外，软件（有时硬件）可能包含缺陷；因此，故障处理器的行为不仅限于停止运行，如在崩溃故障模型中假设的那样。显然，软件错误的影响事先无法确定。那么，如何模拟故障处理器的行为呢？

The Byzantine fault model assumes that the processor is controlled by an adversary that "fights" against the rest of the processors in order to prevent them from reaching their goal. A Byzantine processor can send any message at any time to each of its neighbors. Initially, algorithms that tolerate Byzantine faults were designed for flight devices that must be extremely robust. Several processors that are executing programs for the task communicate the result and decide which result is correct. Unfortunately, it is well known that, if one-third (or more) of the processors are Byzantine, it is impossible to achieve basic tasks such as consensus in distributed systems.

拜占庭故障模型假设处理器受到一个敌手的控制，该敌手“对抗”其余的处理器，以阻止它们实现目标。一个拜占庭处理器可以在任何时候向每个邻居发送任何消息。最初，能够容忍拜占庭故障的算法是为必须极其稳健的飞行设备设计的。执行任务的多个处理器通过通信结果来决定哪个结果是正确的。不幸的是，众所周知，如果三分之一（或更多）的处理器是拜占庭的，那么在分布式系统中实现基本任务（如达成一致意见）是不可能的。

For example, consider a system of three processor $P_1$, $P_2$, and $P_3$ that are connected to one another. Each processor has a single input bit. The task of the non-faulty processors is to choose the same value. Moreover, when the non-faulty processors have the same input, that input must be chosen. Assume there is a distributed algorithm $\mathcal{AL}$ that achieves consensus in the presence of a single Byzantine processor in the above system. Note that if we prove that no non-stabilizing algorithm can ensure that consensus is eventually achieved (assuming the executions start in a particular initial configuration), then it is clear that no self-stabilizing algorithm for this task exists.

例如，考虑一个由三个处理器 $P_1$, $P_2$ 和 $P_3$ 组成的系统，它们相互连接。每个处理器有一个输入位。非故障处理器的任务是选择相同的值。此外，当非故障处理器具有相同的输入时，必须选择该输入。假设有一个分布式算法 $\mathcal{AL}$ 可以在上述系统中存在一个拜占庭处理器的情况下实现一致性。请注意，如果我们证明在特定初始配置下开始执行的情况下，没有非稳定算法可以确保最终达成一致，那么显然不存在用于该任务的自稳定算法。

Consider a six-processor ring $P_1$, $P_2$, $P_3$, $P'_1$, $P'_2$, $P'_3$, where $P_1$ is connected to $P'_3$ and each $P_x$, $x \in \{1, 2, 3\}$, is identical to $P'_x$. $P_x$ and $P'_x$ run the same program as defined by $\mathcal{AL}$ for $P_x$ in the three-processor system. $P_x$ and $P'_x$ may have different input values. In particular, let the input values of the processors in the ring be 0, 0, 0, 1, 1, 1 for $P_1$, $P_2$, $P_3$, $P'_1$, $P'_2$, $P'_3$, respectively. Analyze the executions of $\mathcal{AL}$ on the ring. Note that $\mathcal{AL}$ is designed to be executed on a system with only three processors $P_1$, $P_2$ and $P_3$; we examine it only to prove the impossibility result using a ring of six processors. Furthermore, no processor is faulty in the executions examined. Thus, $P_2$ and $P_3$ must choose 0 since they both have input 0 and the information received from $P_1$ and $P'_1$ in the ring can be produced by a single Byzantine processor, namely $P_1$ in the three-processor system. On the other hand, $P'_1$ and $P'_2$ both have input 1 and the communication with $P_3$ and $P'_3$ during the execution can be produced by a Byzantine processor. Thus $P'_1$ and $P'_2$ must choose 1. The final observation is the output of $P_3$ and $P'_1$. Recall that no processor is faulty in the ring execution. Thus, both $P_3$ and $P'_1$ are non-faulty and the communication pattern between $P_2$ and $P_3$ and between $P'_1$ and $P'_2$ may be produced by a single Byzantine processor in the three-processor system that is connected to $P_3$ and $P'_1$. Thus, $P_3$ and $P'_1$ must decide on one input. The proof is complete, since we have previously proved that $P_3$ must choose 0 and $P'_1$ must choose 1.

考虑一个由六个处理器组成的环 $P_1$, $P_2$, $P_3$, $P'_1$, $P'_2$, $P'_3$，其中 $P_1$ 连接到 $P'_3$，并且每个 $P_x$（$x \in \{1, 2, 3\}$）与 $P'_x$ 是相同的。$P_x$ 和 $P'_x$ 运行在三处理器系统中由 $\mathcal{AL}$ 定义的相同程序。$P_x$ 和 $P'_x$ 可能具有不同的输入值。特别地，假设环中处理器的输入值分别为 $P_1$、$P_2$、$P_3$、$P'_1$、$P'_2$、$P'_3$ 的输入值是 0, 0, 0, 1, 1, 1。分析 $\mathcal{AL}$ 在环上的执行情况。注意，$\mathcal{AL}$ 被设计为在仅有三个处理器 $P_1$，$P_2$ 和 $P_3$ 的系统上执行；我们仅通过使用六个处理器的环来证明不可能性结果。而且，在所研究的执行中没有处理器发生故障。因此，$P_2$ 和 $P_3$ 必须选择 0，因为它们都具有输入 0，并且从环中的 $P_1$ 和 $P'_1$ 接收到的信息可以由单个拜占庭处理器（即三处理器系统中的 $P_1$）产生。另一方面，$P'_1$ 和 $P'_2$ 都具有输入 1，并且在执行过程中与 $P_3$ 和 $P'_3$ 的通信可以由一个拜占庭处理器产生。因此，$P'_1$ 和 $P'_2$ 必须选择 1。最终的观察点是 $P_3$ 和 $P'_1$ 的输出。回顾一下，在环的执行中没有处理器发生故障。因此，$P_3$ 和 $P'_1$ 都是非故障的，并且 $P_2$ 和 $P_3$ 以及 $P'_1$ 和 $P'_2$ 之间的通信模式可能由三处理器系统中连接到 $P_3$ 和 $P'_1$ 的单个拜占庭处理器产生。因此，$P_3$ 和 $P'_1$ 必须决定一个输入。证明完成，因为我们之前已经证明 $P_3$ 必须选择 0 而 $P'_1$ 必须选择 1。

Is this a special case? Is it perhapes possible to reach consensus when the number of processors is $3f$, where $f > 1$ is the number of Byzantine processors? The rough idea for proving the impossibility result is logically to partition the system into three clusters of processors, one of which contains all the Byzantine processors. Each cluster can be replaced by a single superprocessor that simulates the execution of the cluster (including the communication within and outside the cluster). Thus the existence of an algorithm for the case $3f$, $f > 1$, implies existence for the case $f = 1$, which in turn we proved impossible.

这是一个特殊情况吗？在处理器数量为 $3f$ 的情况下，有可能达成一致吗，其中 $f > 1$ 是拜占庭处理器的数量？证明不可能性结果的粗略思路是将系统逻辑上划分为三个处理器集群，其中一个集群包含所有拜占庭处理器。每个集群可以替换为一个超级处理器，该处理器模拟集群的执行（包括集群内和集群外的通信）。因此，对于 $3f$，$f > 1$ 的情况存在算法意味着对于 $f = 1$ 的情况存在算法，而我们已经证明这是不可能的。

Now that we have proved the limitations of algorithms designed to cope with Byzantine faults, we may ask: Is it reasonable to assume that during any period of the execution less than one-third of the processors are faulty? What happens if, for a short period, more than one-third of the processors are faulty, or perhaps temporarily crashed? What happens if messages sent by non-faulty processors are lost in one instant of time? The answer to these questions is similar in flavor to the answer concerning the influence of program flaws. Such temporary violations of the assumptions can be viewed as leaving the system in an arbitrary initial state that could have been chosen by a malicious adversary and from which the algorithm resumes.

既然我们已经证明了旨在应对拜占庭故障的算法的局限性，我们可以问：假设在执行的任何期间少于三分之一的处理器发生故障是合理的吗？如果在一个短时间内超过三分之一的处理器发生故障或暂时崩溃，会发生什么？如果非故障处理器发送的消息在某一瞬间丢失，会发生什么？这些问题的答案在风格上类似于关于程序缺陷影响的答案。这种对假设的临时违反可以被视为使系统处于恶意对手可能选择的任意初始状态，从该状态继续执行算法。

An algorithm designed to cope with both Byzantine faults and transient faults may be able to cope with severe faults that are not tolerated by an algorithm that copes with only one type of faults. Self-stabilizing algorithms that cope with ongoing faults and stabilize in spite of these faults are presented in this chapter. The existence of such algorithms demonstrates once again the generality of the self-stabilization concept. One can require stabilization whenever certain conditions hold, for example convergence to a safe configuration when less than one-third of the processors are Byzantine. To demonstrate the integration of self-stabilization with other fault concepts, we start by presenting self-stabilizing algorithms for the elegant and simple digital clock-synchronization problem. The digital clock-synchronization problem assumes a synchronous system in which the processors are activated by a global clock pulse. We follow this with the case of asynchronous systems.

一种旨在同时应对拜占庭故障和瞬态故障的算法可能能够应对仅处理一种故障类型的算法不能容忍的严重故障。本章介绍了应对持续故障并在这些故障下稳定的自稳定算法。这类算法的存在再次证明了自稳定性概念的普遍性。只要某些条件成立，就可以要求稳定，例如当少于三分之一的处理器是拜占庭时，收敛到安全配置。为了展示自稳定性与其他故障概念的集成，我们首先介绍用于优雅且简单的数字时钟同步问题的自稳定算法。数字时钟同步问题假设一个同步系统，其中处理器由全局时钟脉冲激活。随后，我们介绍异步系统的情况。
